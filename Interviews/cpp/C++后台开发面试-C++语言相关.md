**1. 虚函数**

实现多态所必须， 当有虚函数时，类会有一个虚表，对于一个实例，会有一个虚指针（只有
一个）指向虚表，执行前查表。
有子类时，析构函数必须是虚函数。构造函数不能是虚函数（指针未构造）。
构造析构调用虚函数不起作用：未初始化 or 已被销毁。
另一个优点：实现封装。

**2. 智能指针**
智能指针是一个类， 构造函数中传入一个普通指针（ explicit 显式），析构函数中释放传
入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。
**std::auto_ptr**：转移所有权。 不支持复制（拷贝构造函数）和赋值（ operator =），但复制
或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。
**unique_ptr**，也不支持复制和赋值，但比 **auto_ptr** 好，直接赋值会编译出错。实在想赋值
的话，需要使用：std::move 或者 右边是一个临时对象。
**shared_ptr**，基于引用计数。
**weak_ptr**，弱引用， 只引用，不计数。引用计数有一个问题就是互相引用形成环，这样两个
指针指向的内存都无法释放。 **weak_ptr** 不保证它指向的内存一定是有效的，在使用之前需
要检查 **weak_ptr** 是否为空指针。

**3. 模板特化**: 特化（函数、类）、偏特化（类、指针、引用）， template<>

**4. extern**
外部变量声明（ 在其他模块找定义）， 还可用来指定链接（ extern ‘C’）
Const 变量要能在外部访问，定义时要加 extern。

**5. volatile**: 可能会意想不到地改变，直接从内存存取（不用寄存器缓存）

**6. 指针 vs 引用**

非空区别：引用必须指向某对象，指针可为空；
合法性区别：指针可为空，所以用前要检查；
指向可修改区别；
指针要解引用；sizeof 结果不同；自增意义不同；引用不分配内存。

**7. Static**

1.隐藏（仅当前文件可见）；2.内容持久；3.初始化为 0；
4.C++:属于类不属于对象，必须类外定义（不加 static），无 this 指针，只能访问 static 成员

**8. 内存分布**: 程序代码区、文字常量区、全局/静态区、 heap(-->)、 stack()

**9. Const vs #define** : Const 有类型检查，安全。

**10. 只能用初始化列表**： const，引用成员变量

**11. 指针 & 数组名**: 前者可移动，后者不可变， sizeof 不一样

**12. Sizeof**：求字节数，不进行计算、不能求动态分配的内存大小。

**13. 内存对齐**: 1.自身对齐：地址为自身大小的整数倍； 2.整体对齐：为最大成员的整数倍。

**14. 为什么要有继承**：1.清楚定义对象的特性，减少冗余代码；2.多态性；3.重用
